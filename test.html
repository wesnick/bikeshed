<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ProseMirror Rich Text Editor with Bulma</title>

  <!-- Bulma CSS -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/bulma/0.9.4/css/bulma.min.css">

  <!-- Font Awesome for icons -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css">

  <!-- ProseMirror and related libraries using ESM via skypack -->
  <script type="importmap">
    {
      "imports": {
        "prosemirror-state": "https://cdn.skypack.dev/prosemirror-state",
        "prosemirror-view": "https://cdn.skypack.dev/prosemirror-view",
        "prosemirror-model": "https://cdn.skypack.dev/prosemirror-model",
        "prosemirror-schema-basic": "https://cdn.skypack.dev/prosemirror-schema-basic",
        "prosemirror-schema-list": "https://cdn.skypack.dev/prosemirror-schema-list",
        "prosemirror-keymap": "https://cdn.skypack.dev/prosemirror-keymap",
        "prosemirror-commands": "https://cdn.skypack.dev/prosemirror-commands",
        "prosemirror-history": "https://cdn.skypack.dev/prosemirror-history",
        "prosemirror-markdown": "https://cdn.skypack.dev/prosemirror-markdown"
      }
    }
  </script>

  <!-- PrismJS for syntax highlighting -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prismjs/1.29.0/prism.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prismjs/1.29.0/components/prism-javascript.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prismjs/1.29.0/components/prism-python.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prismjs/1.29.0/components/prism-css.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prismjs/1.29.0/components/prism-markup.min.js"></script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prismjs/1.29.0/themes/prism.min.css">

  <style>
    .editor {
      border: 1px solid #dbdbdb;
      border-radius: 4px;
      padding: 1rem;
      min-height: 200px;
      background-color: white;
    }

    .ProseMirror {
      outline: none;
      min-height: 150px;
    }

    .ProseMirror p {
      margin-bottom: 0.5rem;
    }

    .ProseMirror pre {
      background-color: #f5f5f5;
      border-radius: 4px;
      padding: 1rem;
      margin: 1rem 0;
      white-space: pre-wrap;
    }

    .ProseMirror code {
      font-family: monospace;
    }

    .slash-menu {
      position: absolute;
      background: white;
      border: 1px solid #dbdbdb;
      border-radius: 4px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
      z-index: 10;
      width: 250px;
      max-height: 300px;
      overflow-y: auto;
    }

    .slash-menu-item {
      padding: 8px 12px;
      cursor: pointer;
      display: flex;
      align-items: center;
    }

    .slash-menu-item:hover {
      background-color: #f5f5f5;
    }

    .slash-menu-item-icon {
      margin-right: 8px;
      width: 20px;
      text-align: center;
    }

    .slash-menu-search {
      padding: 8px;
      border-bottom: 1px solid #dbdbdb;
    }

    .slash-menu-search input {
      width: 100%;
      padding: 6px;
      border: 1px solid #dbdbdb;
      border-radius: 4px;
    }

    .ProseMirror .code-block {
      background-color: #f5f5f5;
      border-radius: 4px;
      font-family: monospace;
      position: relative;
    }

    .ProseMirror .code-block pre {
      margin: 0;
      counter-reset: line;
    }

    .ProseMirror .code-language {
      position: absolute;
      top: 5px;
      right: 10px;
      font-size: 0.8rem;
      color: #7a7a7a;
    }

    /* Custom styles for code highlighting */
    .token.comment,
    .token.prolog,
    .token.doctype,
    .token.cdata {
      color: #999;
    }

    .token.punctuation {
      color: #555;
    }

    .token.namespace {
      opacity: 0.7;
    }

    .token.property,
    .token.tag,
    .token.boolean,
    .token.number,
    .token.constant,
    .token.symbol {
      color: #905;
    }

    .token.selector,
    .token.attr-name,
    .token.string,
    .token.char,
    .token.builtin {
      color: #690;
    }

    .token.operator,
    .token.entity,
    .token.url,
    .language-css .token.string,
    .style .token.string,
    .token.variable {
      color: #07a;
    }

    .token.atrule,
    .token.attr-value,
    .token.keyword {
      color: #07a;
    }

    .token.function {
      color: #DD4A68;
    }

    .token.regex,
    .token.important {
      color: #e90;
    }

    .token.important,
    .token.bold {
      font-weight: bold;
    }

    .token.italic {
      font-style: italic;
    }

    .token.entity {
      cursor: help;
    }
  </style>
</head>
<body>
  <section class="section">
    <div class="container">
      <h1 class="title is-3">Rich Text Editor with ProseMirror</h1>
      <p class="subtitle is-5 mb-4">Type '/' for commands | Use ``` for code blocks</p>

      <form class="form">
        <div class="field">
          <label class="label">Title</label>
          <div class="control">
            <input class="input" type="text" placeholder="Enter title">
          </div>
        </div>

        <div class="field">
          <label class="label">Content</label>
          <div class="control">
            <div id="editor" class="editor"></div>
          </div>
          <p class="help">Support for GitHub Flavored Markdown</p>
        </div>

        <div class="field mt-5">
          <div class="control">
            <button class="button is-primary" type="button" id="submit-button">Submit</button>
            <button class="button is-light ml-2" type="button" id="reset-button">Reset</button>
          </div>
        </div>

        <div class="field mt-4">
          <label class="label">Preview</label>
          <div class="control">
            <div id="preview" class="box"></div>
          </div>
        </div>
      </form>
    </div>
  </section>

  <!-- Main script using ES modules -->
  <script type="module">
    // Import ProseMirror modules
    import { EditorState } from "prosemirror-state";
    import { EditorView } from "prosemirror-view";
    import { Schema, DOMParser } from "prosemirror-model";
    import { schema as basicSchema } from "prosemirror-schema-basic";
    import { addListNodes } from "prosemirror-schema-list";
    import { keymap } from "prosemirror-keymap";
    import { baseKeymap, chainCommands, newlineInCode, createParagraphNear, liftEmptyBlock, splitBlock } from "prosemirror-commands";
    import { history, undo, redo } from "prosemirror-history";

    // Wait for DOM to be ready
    document.addEventListener('DOMContentLoaded', () => {
      // Define a custom schema extending the basic schema
      const mySchema = new Schema({
        nodes: {
          // Basic nodes
          doc: {
            content: "block+"
          },
          paragraph: {
            content: "inline*",
            group: "block",
            parseDOM: [{tag: "p"}],
            toDOM() { return ["p", 0] }
          },
          blockquote: {
            content: "block+",
            group: "block",
            parseDOM: [{tag: "blockquote"}],
            toDOM() { return ["blockquote", 0] }
          },
          horizontal_rule: {
            group: "block",
            parseDOM: [{tag: "hr"}],
            toDOM() { return ["hr"] }
          },
          heading: {
            attrs: {level: {default: 1}},
            content: "inline*",
            group: "block",
            defining: true,
            parseDOM: [
              {tag: "h1", attrs: {level: 1}},
              {tag: "h2", attrs: {level: 2}},
              {tag: "h3", attrs: {level: 3}},
              {tag: "h4", attrs: {level: 4}},
              {tag: "h5", attrs: {level: 5}},
              {tag: "h6", attrs: {level: 6}}
            ],
            toDOM(node) { return ["h" + node.attrs.level, 0] }
          },
          code_block: {
            attrs: {language: {default: ""}},
            content: "text*",
            group: "block",
            code: true,
            defining: true,
            marks: "",
            parseDOM: [{
              tag: "pre",
              preserveWhitespace: "full",
              getAttrs: node => ({language: node.getAttribute("data-language") || ""})
            }],
            toDOM(node) {
              return [
                "div", {class: "code-block"},
                ["div", {class: "code-language"}, node.attrs.language],
                ["pre", {"data-language": node.attrs.language}, ["code", {class: `language-${node.attrs.language}`}, 0]]
              ]
            }
          },
          text: {
            group: "inline"
          },
          image: {
            inline: true,
            attrs: {
              src: {},
              alt: {default: null},
              title: {default: null}
            },
            group: "inline",
            draggable: true,
            parseDOM: [{
              tag: "img[src]",
              getAttrs(dom) {
                return {
                  src: dom.getAttribute("src"),
                  alt: dom.getAttribute("alt"),
                  title: dom.getAttribute("title")
                }
              }
            }],
            toDOM(node) {
              return ["img", node.attrs]
            }
          },
          hard_break: {
            inline: true,
            group: "inline",
            selectable: false,
            parseDOM: [{tag: "br"}],
            toDOM() { return ["br"] }
          }
        },
        marks: {
          em: {
            parseDOM: [{tag: "i"}, {tag: "em"}, {style: "font-style=italic"}],
            toDOM() { return ["em"] }
          },
          strong: {
            parseDOM: [{tag: "strong"}, {tag: "b"}, {style: "font-weight=bold"}],
            toDOM() { return ["strong"] }
          },
          code: {
            parseDOM: [{tag: "code"}],
            toDOM() { return ["code"] }
          },
          link: {
            attrs: {
              href: {},
              title: {default: null}
            },
            inclusive: false,
            parseDOM: [{
              tag: "a[href]",
              getAttrs(dom) {
                return {href: dom.getAttribute("href"), title: dom.getAttribute("title")}
              }
            }],
            toDOM(node) { return ["a", node.attrs, 0] }
          }
        }
      });

      // Plugin to handle slash commands
      class SlashCommandPlugin {
        constructor(view) {
          this.view = view;
          this.slashMenuOpen = false;
          this.slashMenuEl = null;
          this.slashMenuPosition = null;
          this.slashMenuItems = [
            {
              id: 'heading1',
              title: 'Heading 1',
              icon: 'heading',
              execute: () => this.insertHeading(1)
            },
            {
              id: 'heading2',
              title: 'Heading 2',
              icon: 'heading',
              execute: () => this.insertHeading(2)
            },
            {
              id: 'heading3',
              title: 'Heading 3',
              icon: 'heading',
              execute: () => this.insertHeading(3)
            },
            {
              id: 'bullet-list',
              title: 'Bullet List',
              icon: 'list-ul',
              execute: () => this.insertBulletList()
            },
            {
              id: 'numbered-list',
              title: 'Numbered List',
              icon: 'list-ol',
              execute: () => this.insertNumberedList()
            },
            {
              id: 'blockquote',
              title: 'Blockquote',
              icon: 'quote-left',
              execute: () => this.insertBlockquote()
            },
            {
              id: 'code-block',
              title: 'Code Block',
              icon: 'code',
              execute: () => this.insertCodeBlock()
            },
            {
              id: 'hr',
              title: 'Horizontal Rule',
              icon: 'minus',
              execute: () => this.insertHorizontalRule()
            },
            {
              id: 'img',
              title: 'Image',
              icon: 'image',
              execute: () => this.insertImage()
            }
          ];

          this.createSlashMenu();
        }

        createSlashMenu() {
          const menu = document.createElement('div');
          menu.className = 'slash-menu';
          menu.style.display = 'none';

          const searchBox = document.createElement('div');
          searchBox.className = 'slash-menu-search';
          searchBox.innerHTML = `<input type="text" placeholder="Filter commands...">`;
          menu.appendChild(searchBox);

          const menuItems = document.createElement('div');
          menuItems.className = 'slash-menu-items';

          this.slashMenuItems.forEach(item => {
            const menuItem = document.createElement('div');
            menuItem.className = 'slash-menu-item';
            menuItem.dataset.id = item.id;
            menuItem.innerHTML = `
              <span class="slash-menu-item-icon">
                <i class="fas fa-${item.icon}"></i>
              </span>
              <span>${item.title}</span>
            `;
            menuItem.addEventListener('click', () => {
              this.executeSlashCommand(item.id);
              this.closeSlashMenu();
            });
            menuItems.appendChild(menuItem);
          });

          menu.appendChild(menuItems);
          document.body.appendChild(menu);

          const searchInput = searchBox.querySelector('input');
          searchInput.addEventListener('input', () => {
            const value = searchInput.value.toLowerCase();

            const items = menuItems.querySelectorAll('.slash-menu-item');
            items.forEach(item => {
              const text = item.textContent.toLowerCase();
              item.style.display = text.includes(value) ? 'flex' : 'none';
            });
          });

          this.slashMenuEl = menu;

          // Close the menu when clicking outside
          document.addEventListener('click', event => {
            if (this.slashMenuOpen && !menu.contains(event.target)) {
              this.closeSlashMenu();
            }
          });
        }

        openSlashMenu(pos) {
          const editorRect = this.view.dom.getBoundingClientRect();
          const coords = this.view.coordsAtPos(pos);

          this.slashMenuEl.style.left = `${coords.left - editorRect.left}px`;
          this.slashMenuEl.style.top = `${coords.bottom - editorRect.top + 5}px`;
          this.slashMenuEl.style.display = 'block';

          const searchInput = this.slashMenuEl.querySelector('input');
          searchInput.value = '';
          searchInput.focus();

          // Show all items
          const items = this.slashMenuEl.querySelectorAll('.slash-menu-item');
          items.forEach(item => {
            item.style.display = 'flex';
          });

          this.slashMenuOpen = true;
          this.slashMenuPosition = pos;
        }

        closeSlashMenu() {
          this.slashMenuEl.style.display = 'none';
          this.slashMenuOpen = false;
          this.slashMenuPosition = null;
        }

        executeSlashCommand(commandId) {
          const command = this.slashMenuItems.find(item => item.id === commandId);
          if (command) {
            command.execute();
          }
        }

        update(view, prevState) {
          this.view = view;

          const state = view.state;
          const selection = state.selection;

          // Find the slash command
          if (selection.empty) {
            const $pos = selection.$from;
            const textBefore = $pos.parent.textContent.slice(0, $pos.parentOffset);

            if (textBefore.endsWith('/')) {
              // Open slash menu
              this.openSlashMenu($pos.pos);
            } else if (this.slashMenuOpen && !textBefore.includes('/')) {
              // Close slash menu if there's no slash
              this.closeSlashMenu();
            }
          }
        }

        insertHeading(level) {
          const { state, dispatch } = this.view;

          // Delete the slash character
          const { $from } = state.selection;
          const transaction = state.tr.delete($from.pos - 1, $from.pos);

          // Insert heading node
          const nodeType = mySchema.nodes.heading;
          dispatch(transaction.replaceSelectionWith(nodeType.create({ level })));

          this.view.focus();
        }

        insertBlockquote() {
          const { state, dispatch } = this.view;

          // Delete the slash character
          const { $from } = state.selection;
          const transaction = state.tr.delete($from.pos - 1, $from.pos);

          // Insert blockquote node
          const nodeType = mySchema.nodes.blockquote;
          const paragraph = mySchema.nodes.paragraph.create();
          dispatch(transaction.replaceSelectionWith(nodeType.create({}, paragraph)));

          this.view.focus();
        }

        insertCodeBlock() {
          const { state, dispatch } = this.view;

          // Delete the slash character
          const { $from } = state.selection;
          const transaction = state.tr.delete($from.pos - 1, $from.pos);

          // Insert code block node
          const nodeType = mySchema.nodes.code_block;
          dispatch(transaction.replaceSelectionWith(nodeType.create({ language: 'javascript' })));

          this.view.focus();
        }

        insertHorizontalRule() {
          const { state, dispatch } = this.view;

          // Delete the slash character
          const { $from } = state.selection;
          const transaction = state.tr.delete($from.pos - 1, $from.pos);

          // Insert horizontal rule node
          const nodeType = mySchema.nodes.horizontal_rule;
          dispatch(transaction.replaceSelectionWith(nodeType.create()));

          this.view.focus();
        }

        insertBulletList() {
          const { state, dispatch } = this.view;

          // Delete the slash character
          const { $from } = state.selection;
          const transaction = state.tr.delete($from.pos - 1, $from.pos);

          // We'd need to create a proper list plugin for this to work
          // For now, let's just create a paragraph with a bullet character
          const nodeType = mySchema.nodes.paragraph;
          dispatch(transaction.replaceSelectionWith(nodeType.create(
            null,
            mySchema.text('â€¢ ')
          )));

          this.view.focus();
        }

        insertNumberedList() {
          const { state, dispatch } = this.view;

          // Delete the slash character
          const { $from } = state.selection;
          const transaction = state.tr.delete($from.pos - 1, $from.pos);

          // We'd need to create a proper list plugin for this to work
          // For now, let's just create a paragraph with a number
          const nodeType = mySchema.nodes.paragraph;
          dispatch(transaction.replaceSelectionWith(nodeType.create(
            null,
            mySchema.text('1. ')
          )));

          this.view.focus();
        }

        insertImage() {
          const { state, dispatch } = this.view;

          // Delete the slash character
          const { $from } = state.selection;
          const transaction = state.tr.delete($from.pos - 1, $from.pos);

          // Prompt for image URL
          const url = prompt('Enter image URL:');
          if (url) {
            // Insert image node
            const nodeType = mySchema.nodes.image;
            dispatch(transaction.replaceSelectionWith(nodeType.create({ src: url, alt: 'Image' })));
          } else {
            // Just delete the slash
            dispatch(transaction);
          }

          this.view.focus();
        }
      }

      // Plugin to handle code blocks and syntax highlighting
      class CodeBlockPlugin {
        constructor(view) {
          this.view = view;
          this.updating = false;
        }

        update(view, prevState) {
          this.view = view;

          if (this.updating) return;
          this.updating = true;

          // Find all code blocks and apply syntax highlighting
          const nodes = document.querySelectorAll('.ProseMirror pre code');
          nodes.forEach(node => {
            const parent = node.closest('.code-block');
            if (parent) {
              const language = parent.querySelector('.code-language').textContent;
              if (language && !node.classList.contains(`language-${language}`)) {
                node.className = `language-${language}`;
                Prism.highlightElement(node);
              }
            }
          });

          this.updating = false;
        }

        // Check if we need to insert a code block
        handleKeyDown(view, event) {
          if (event.key === '`' && this.checkForTripleBacktick(view)) {
            const { state, dispatch } = view;
            const { $from } = state.selection;

            // Delete the triple backtick
            let transaction = state.tr.delete($from.pos - 3, $from.pos);

            // Insert code block
            const nodeType = mySchema.nodes.code_block;
            dispatch(transaction.replaceSelectionWith(nodeType.create({ language: 'javascript' })));

            return true;
          }
          return false;
        }

        checkForTripleBacktick(view) {
          const { state } = view;
          const { $from } = state.selection;
          const textBefore = $from.parent.textContent.slice(0, $from.parentOffset);

          return textBefore.endsWith('``');
        }
      }

      // Create and mount the editor
      const editorElement = document.getElementById('editor');
      const previewElement = document.getElementById('preview');

      // Set up the editor state
      const state = EditorState.create({
        schema: mySchema,
        plugins: [
          history(),
          keymap({
            'Mod-z': undo,
            'Mod-y': redo,
            'Shift-Mod-z': redo,
            'Enter': chainCommands(
              newlineInCode,
              createParagraphNear,
              liftEmptyBlock,
              splitBlock
            )
          }),
          keymap(baseKeymap)
        ]
      });

      // Create the editor view
      const view = new EditorView(editorElement, {
        state,
        dispatchTransaction(transaction) {
          const newState = view.state.apply(transaction);
          view.updateState(newState);

          // Update the preview
          updatePreview();
        }
      });

      // Initialize plugins
      const slashPlugin = new SlashCommandPlugin(view);
      const codeBlockPlugin = new CodeBlockPlugin(view);

      // Add event listener for key down
      view.dom.addEventListener('keydown', (event) => {
        if (codeBlockPlugin.handleKeyDown(view, event)) {
          event.preventDefault();
        }
      });

      // Function to update the preview
      function updatePreview() {
        const content = view.dom.innerHTML;
        previewElement.innerHTML = content;

        // Update plugins
        slashPlugin.update(view, view.state);
        codeBlockPlugin.update(view, view.state);

        // Apply syntax highlighting to the preview
        const codeBlocks = previewElement.querySelectorAll('pre code');
        codeBlocks.forEach(block => {
          Prism.highlightElement(block);
        });
      }

      // Handle form buttons
      document.getElementById('submit-button').addEventListener('click', () => {
        alert('Form submitted!');
      });

      document.getElementById('reset-button').addEventListener('click', () => {
        // Create a new state with empty content
        const newState = EditorState.create({
          schema: mySchema,
          plugins: [
            history(),
            keymap({
              'Mod-z': undo,
              'Mod-y': redo,
              'Shift-Mod-z': redo,
              'Enter': chainCommands(
                newlineInCode,
                createParagraphNear,
                liftEmptyBlock,
                splitBlock
              )
            }),
            keymap(baseKeymap)
          ]
        });

        view.updateState(newState);
        updatePreview();
      });

      // Initialize the preview
      updatePreview();
    });
  </script>
</body>
</html>